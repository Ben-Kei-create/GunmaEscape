import { useGameStore } from '../stores/gameStore';
import { usePlayerStore } from '../stores/playerStore';
import { useCardStore } from '../stores/cardStore';
import type { Enemy } from '../types';
import legacyCardsData from '../assets/data/legacyCards.json';
import type { LegacyCard } from '../types';
import { achievementManager } from './AchievementManager';
import { hapticsManager } from './HapticsManager';

// Victory callback to advance scenario
let victoryCallback: ((enemyId: string) => void) | null = null;

export const setVictoryCallback = (callback: (enemyId: string) => void) => {
  victoryCallback = callback;
};

// Card discovery on victory
export const discoverCardOnVictory = (enemyId: string) => {
  const cardStore = useCardStore.getState();

  // Map enemy IDs to potential card discoveries
  const cardRewards: Record<string, string[]> = {
    'event_001': ['card_004'], // Konnyaku monster -> Konnyaku card
  };

  const possibleCards = cardRewards[enemyId] || [];
  if (possibleCards.length > 0) {
    const cardId = possibleCards[Math.floor(Math.random() * possibleCards.length)];
    if (!cardStore.hasCard(cardId)) {
      cardStore.addCard(cardId);
      const allCards = legacyCardsData.cards as LegacyCard[];
      const card = allCards.find(c => c.id === cardId);
      if (card) {
        useGameStore.getState().addLog(`> ã€ã‚«ãƒ¼ãƒ‰ç™ºè¦‹ã€‘${card.name}ã‚’å›³é‘‘ã«ç™»éŒ²ã—ã¾ã—ãŸï¼`, 'story');
      }
    }
  }
};

export class BattleSystem {
  private gameStore = useGameStore;
  private playerStore = usePlayerStore;
  private cardStore = useCardStore;

  private getActiveCards(): LegacyCard[] {
    const collectedCards = this.cardStore.getState().getAllCollectedCards();
    const allCards = legacyCardsData.cards as LegacyCard[];
    return allCards.filter(card => collectedCards.includes(card.id));
  }

  // private applyCardEffects() { ... } // Removed unused method


  startBattle(enemy: Enemy) {
    const playerState = this.playerStore.getState();

    // Apply battle start card effects (like Kusatsu Onsen)
    const activeCards = this.getActiveCards();
    activeCards.forEach(card => {
      if (card.effect.type === 'heal' && card.id === 'card_005') {
        const heal = card.effect.value || 0;
        const newHp = Math.min(playerState.maxHp, playerState.hp + heal);
        this.playerStore.setState({ hp: newHp });
        this.gameStore.getState().addLog(`> ${card.name}ã®åŠ¹æœ: HPãŒ${heal}å›å¾©ã—ãŸ`, 'heal');
      }
    });

    this.gameStore.setState({
      battleState: {
        isActive: true,
        turn: 'player',
        enemy: { ...enemy },
        playerDice1: null,
        playerDice2: null,
        lastPlayerDamage: 0,
        lastEnemyDamage: 0,
      },
      currentMode: 'battle',
    });

    // Initial battle card should be generated by the UI/Scenario manager observing the state
    // We don't generate it here because we might want an initial "Encounter" message card first.
  }

  // Generate a card representing the current battle turn
  generateBattleCard(): any {
    const battleState = this.gameStore.getState().battleState;
    if (!battleState || !battleState.enemy) return null;

    const enemy = battleState.enemy;

    // Randomize enemy intent
    // 0: Attack (Aggressive)
    // 1: Vulnerable (Gap)
    // 2: Observing (Normal)
    const intentRoll = Math.random();
    let intent: 'attack' | 'vulnerable' | 'observing' = 'observing';
    let title = '';
    let description = '';
    let image = `/assets/enemies/enemy_${enemy.id.includes('daruma') ? 'daruma' : 'konnyaku'}.png`;

    if (intentRoll < 0.5) {
      intent = 'attack';
      title = `âš ï¸ ${enemy.name}ãŒæ§‹ãˆã¦ã„ã‚‹ï¼`;
      description = 'æ®ºæ°—ã‚’æ„Ÿã˜ã‚‹... æ”»æ’ƒã—ã¦ãã‚‹ãï¼\n(å·¦: é˜²å¾¡ / å³: ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼)';
    } else if (intentRoll < 0.8) {
      intent = 'vulnerable';
      title = `âš¡ ${enemy.name}ã¯éš™ã ã‚‰ã‘ã ï¼`;
      description = 'ä»Šãªã‚‰å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‰ã‚Œã‚‹ãƒãƒ£ãƒ³ã‚¹ï¼\n(å·¦: æ§˜å­è¦‹ / å³: æ”»æ’ƒ)';
    } else {
      intent = 'observing';
      title = `ğŸ‘ï¸ ${enemy.name}ã¯ã“ã¡ã‚‰ã‚’è¦‹ã¦ã„ã‚‹`;
      description = 'æ…é‡ã«å‹•ã„ã¦ã„ã‚‹ã‚ˆã†ã ã€‚\n(å·¦: ç‰½åˆ¶ / å³: æ”»æ’ƒ)';
    }

    return {
      id: `battle_${Date.now()}`,
      type: 'battle',
      title: title,
      description: description,
      image: image,
      meta: { intent },
      leftText: 'ğŸ›¡ï¸ é˜²å¾¡/å›é¿',
      rightText: 'âš”ï¸ æ”»æ’ƒ'
    };
  }

  processBattleSwipe(direction: 'left' | 'right', card: any) {
    const gameState = this.gameStore.getState();
    const battleState = gameState.battleState;
    if (!battleState || !battleState.enemy) return;

    const intent = card.meta?.intent || 'observing';
    const enemy = battleState.enemy;

    let playerDamage = 0;
    let enemyDamage = 0;
    let logMessage = '';

    // Logic Matrix
    if (direction === 'right') {
      // Player ATTACKS
      if (intent === 'attack') {
        // Clash! Both take damage
        playerDamage = Math.floor(enemy.attack * 0.8);
        enemyDamage = Math.floor(10 + Math.random() * 5);
        logMessage = `> æ¿€çªï¼ç›¸æ‰“ã¡ã«ãªã£ãŸï¼ (æ•µã«${enemyDamage} / è‡ªåˆ†${playerDamage})`;
      } else if (intent === 'vulnerable') {
        // Critical!
        enemyDamage = Math.floor(20 + Math.random() * 10);
        logMessage = `> ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼éš™ã‚’çªã„ã¦å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ (æ•µã«${enemyDamage})`;
        gameState.triggerCriticalFlash();
      } else {
        // Normal hit
        enemyDamage = Math.floor(10 + Math.random() * 5);
        if (Math.random() > 0.7) {
          playerDamage = Math.floor(enemy.attack * 0.3);
          logMessage = `> æ”»æ’ƒå‘½ä¸­ï¼ã—ã‹ã—åæ’ƒã‚’å—ã‘ãŸ (æ•µã«${enemyDamage} / è‡ªåˆ†${playerDamage})`;
        } else {
          logMessage = `> æ”»æ’ƒå‘½ä¸­ï¼ (æ•µã«${enemyDamage})`;
        }
      }
    } else {
      // Player DEFENDS / EVADES (Left)
      if (intent === 'attack') {
        // Perfect Dodge / Block
        logMessage = `> æ”»æ’ƒã‚’å›é¿ã—ãŸï¼ãƒãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`;
      } else if (intent === 'vulnerable') {
        // Missed chance
        logMessage = `> æ§˜å­ã‚’è¦‹ãŸ... çµ¶å¥½ã®æ©Ÿä¼šã‚’é€ƒã—ãŸã€‚`;
      } else {
        // Stare down
        logMessage = `> äº’ã„ã«ç¨ã¿åˆã£ã¦ã„ã‚‹... (HPå¾®å›å¾©)`;
        const player = this.playerStore.getState();
        if (player.hp < player.maxHp) {
          this.playerStore.setState({ hp: Math.min(player.maxHp, player.hp + 5) });
        }
      }
    }

    // Apply Damage
    if (enemyDamage > 0) {
      const newEnemyHp = Math.max(0, enemy.hp - enemyDamage);
      this.gameStore.setState(state => ({
        battleState: { ...state.battleState!, enemy: { ...state.battleState!.enemy!, hp: newEnemyHp } }
      }));
    }

    if (playerDamage > 0) {
      const player = this.playerStore.getState();
      const newPlayerHp = Math.max(0, player.hp - playerDamage);
      this.playerStore.setState({ hp: newPlayerHp });
      hapticsManager.notificationError();
      gameState.triggerScreenShake();
    } else {
      hapticsManager.notification();
    }

    gameState.addLog(logMessage, 'battle');

    // Check Death
    const result = this.checkBattleEnd();
    if (result) {
      this.endBattle(result);
    }
  }

  checkBattleEnd(): 'victory' | 'defeat' | null {
    const gameState = this.gameStore.getState();
    const battleState = gameState.battleState;
    const playerState = this.playerStore.getState();

    if (!battleState?.isActive) {
      return null;
    }

    if (battleState.enemy && battleState.enemy.hp <= 0) {
      return 'victory';
    }

    if (playerState.hp <= 0) {
      return 'defeat';
    }

    return null;
  }

  endBattle(result: 'victory' | 'defeat') {
    const gameState = this.gameStore.getState();
    const battleState = gameState.battleState;
    const playerState = this.playerStore.getState();

    if (result === 'victory') {
      // Apply card effects that increase victory rewards
      const activeCards = this.getActiveCards();
      let rewardMultiplier = 1.0;

      activeCards.forEach(card => {
        if (card.effect.type === 'reward' && card.effect.value) {
          rewardMultiplier = Math.max(rewardMultiplier, card.effect.value);
          this.gameStore.getState().addLog(`> ${card.name}ã®åŠ¹æœ: å ±é…¬ãŒ${rewardMultiplier}å€ã«ãªã£ãŸ!`, 'victory');
        }
      });

      // Tutorial Complete Logic
      if (!this.gameStore.getState().hasSeenTutorial) {
        this.gameStore.getState().setHasSeenTutorial(true);
        this.gameStore.getState().addLog('> ã‚·ã‚¹ãƒ†ãƒ ãŒå®Œå…¨åŒæœŸã—ã¾ã—ãŸã€‚å…¨æ©Ÿèƒ½ãŒè§£æ”¾ã•ã‚Œã¾ã™ã€‚', 'story');
      }

      this.gameStore.getState().addLog('> æ¬¡ã®ã‚¨ãƒªã‚¢ã¸é€²ã‚€...', 'info');

      // Discover card on victory
      if (battleState?.enemy?.id) {
        discoverCardOnVictory(battleState.enemy.id);
      }

      // Call victory callback to advance scenario
      if (victoryCallback && battleState?.enemy?.id) {
        victoryCallback(battleState.enemy.id);
      }

      // Phase 36: Track enemy defeats
      this.gameStore.getState().incrementStat('enemiesDefeated');
      achievementManager.onStatChange();

      // Phase 41: Grant exp and trigger result banner
      const expGained = Math.floor(30 + (battleState?.enemy?.hp || 0) * 0.5);
      const prevLevel = this.gameStore.getState().playerLevel;
      this.gameStore.getState().addExp(expGained);
      const newLevel = this.gameStore.getState().playerLevel;

      window.dispatchEvent(new CustomEvent('battleResult', {
        detail: {
          expGained,
          itemsGained: [],
          levelUp: newLevel > prevLevel ? { from: prevLevel, to: newLevel } : undefined
        }
      }));
    } else if (result === 'defeat') {
      // Set game over info
      const cause = battleState?.enemy?.name || 'ä¸æ˜ãªæ•µ';
      const lastDamage = battleState?.lastEnemyDamage || 0;
      this.gameStore.getState().setGameOverInfo({
        cause,
        location: playerState.location,
        lastDamage,
      });

      // Phase 36: Track deaths
      this.gameStore.getState().incrementStat('totalDeaths');
      achievementManager.onStatChange();
    }

    this.gameStore.setState({
      battleState: {
        ...battleState!,
        isActive: false,
      },
      currentMode: result === 'victory' ? 'exploration' : 'gameover',
      diceRollResult: null,
      diceRollResult2: null,
    });
  }

  getCurrentBattleState() {
    return this.gameStore.getState().battleState;
  }
}

